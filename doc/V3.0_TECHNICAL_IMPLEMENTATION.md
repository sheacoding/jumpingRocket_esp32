# ğŸ”§ è¹¦è·³å°ç«ç®­ V3.0 æŠ€æœ¯å®æ–½æ–¹æ¡ˆ

## ğŸ“‹ æŠ€æœ¯æ¶æ„å¯¹æ¯”

### V2.0 vs V3.0 æ¶æ„å¯¹æ¯”

| å±‚çº§ | V2.0 å½“å‰æ¶æ„ | V3.0 ç›®æ ‡æ¶æ„ | ä¸»è¦å˜åŒ– |
|------|---------------|---------------|----------|
| **ç¡¬ä»¶å±‚** | ESP32 DevKit | ESP32-C3 Mini | æ›´å°ä½“ç§¯ï¼Œå†…ç½®å¤©çº¿ |
| **å­˜å‚¨å±‚** | å†…å­˜å˜é‡ | SPIFFSæ–‡ä»¶ç³»ç»Ÿ | æŒä¹…åŒ–å­˜å‚¨ï¼Œå¤§å®¹é‡ |
| **æ•°æ®å±‚** | ä¸´æ—¶æ•°æ® | JSONæ ¼å¼æ–‡ä»¶ | ç»“æ„åŒ–æ•°æ®ï¼Œæ˜“æ‰©å±• |
| **åŠŸèƒ½å±‚** | åŸºç¡€æ¸¸æˆ | å¢å¼ºåŠŸèƒ½é›† | éš¾åº¦é€‰æ‹©ï¼Œå†å²è®°å½• |
| **ç”µæºå±‚** | ç®€å•ä¾›ç”µ | æ™ºèƒ½ç”µæºç®¡ç† | æ·±åº¦ç¡çœ ï¼Œç»­èˆªä¼˜åŒ– |
| **æ‰©å±•å±‚** | æ—  | é¢„ç•™æ¥å£ | Wi-Fi/è“ç‰™å‡†å¤‡ |

## ğŸ”Œ ç¡¬ä»¶é€‚é…æ–¹æ¡ˆ

### ESP32-C3 Mini å¼•è„šè§„åˆ’

```cpp
// include/v3/board_config_v3.h
#ifndef BOARD_CONFIG_V3_H
#define BOARD_CONFIG_V3_H

// ESP32-C3 Mini ä¸“ç”¨é…ç½®
#ifdef BOARD_ESP32_C3_MINI
    #define BOARD_NAME "ESP32-C3 Mini V3.0"
    
    // æ ¸å¿ƒåŠŸèƒ½å¼•è„š
    #define I2C_SDA_PIN         8     // I2Cæ•°æ®çº¿
    #define I2C_SCL_PIN         0    // I2Cæ—¶é’Ÿçº¿
    #define BUTTON_PIN          3     // ç”¨æˆ·æŒ‰é’®
    #define BUZZER_PIN          4     // èœ‚é¸£å™¨PWM
    
    // æ‰©å±•åŠŸèƒ½å¼•è„š
    ~~#define STATUS_LED_PIN      3     // çŠ¶æ€æŒ‡ç¤ºLED~~
    ~~#define BATTERY_ADC_PIN     0     // ç”µæ± ç”µå‹æ£€æµ‹~~
    ~~#define WAKEUP_PIN          9     // æ·±åº¦ç¡çœ å”¤é†’å¼•è„š~~
    
    // ç¡¬ä»¶ç‰¹æ€§é…ç½®
    #define I2C_FREQUENCY       100000  // 100kHzï¼Œç¨³å®šä¼˜å…ˆ
    #define BUTTON_ACTIVE_LEVEL HIGH    // é«˜ç”µå¹³è§¦å‘
    #define BUTTON_PULL_MODE    INPUT_PULLDOWN
    
    // ç”µæºç®¡ç†é…ç½®
    #define DEEP_SLEEP_ENABLED  1
    #define BATTERY_MONITOR_ENABLED 1
    #define LOW_BATTERY_THRESHOLD 3.3   // ä½ç”µé‡é˜ˆå€¼(V)
    
#endif

#endif // BOARD_CONFIG_V3_H
```

### ç”µæºç®¡ç†ç³»ç»Ÿ

```cpp
// src/v3/power_manager.cpp
class PowerManager {
private:
    float battery_voltage;
    bool low_battery_warning;
    uint32_t sleep_timeout;
    
public:
    void init() {
        // é…ç½®ADCç”¨äºç”µæ± ç”µå‹æ£€æµ‹
        analogReadResolution(12);
        analogSetAttenuation(ADC_11db);
        
        // é…ç½®å”¤é†’æº
        esp_sleep_enable_ext0_wakeup(GPIO_NUM_9, 1); // æŒ‰é’®å”¤é†’
        esp_sleep_enable_timer_wakeup(30 * 60 * 1000000ULL); // 30åˆ†é’Ÿå®šæ—¶å”¤é†’
    }
    
    float getBatteryVoltage() {
        int raw = analogRead(BATTERY_ADC_PIN);
        return (raw * 3.3 * 2) / 4095.0; // åˆ†å‹ç”µè·¯è®¡ç®—
    }
    
    bool isLowBattery() {
        return getBatteryVoltage() < LOW_BATTERY_THRESHOLD;
    }
    
    void enterDeepSleep() {
        Serial.println("è¿›å…¥æ·±åº¦ç¡çœ æ¨¡å¼");
        esp_deep_sleep_start();
    }
    
    void handleWakeup() {
        esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
        
        switch(wakeup_reason) {
            case ESP_SLEEP_WAKEUP_EXT0:
                Serial.println("æŒ‰é’®å”¤é†’");
                break;
            case ESP_SLEEP_WAKEUP_TIMER:
                Serial.println("å®šæ—¶å™¨å”¤é†’");
                break;
            default:
                Serial.println("æ­£å¸¸å¯åŠ¨");
                break;
        }
    }
};
```

## ğŸ’¾ æ–‡ä»¶ç³»ç»Ÿè®¾è®¡

### æ•°æ®å­˜å‚¨æ¶æ„

```cpp
// src/v3/file_system.cpp
class FileSystemManager {
private:
    bool fs_initialized;
    
public:
    bool init() {
        if (!SPIFFS.begin(true)) {
            Serial.println("SPIFFSåˆå§‹åŒ–å¤±è´¥");
            return false;
        }
        
        // åˆ›å»ºç›®å½•ç»“æ„
        createDirectoryStructure();
        fs_initialized = true;
        return true;
    }
    
    void createDirectoryStructure() {
        // SPIFFSä¸æ”¯æŒçœŸæ­£çš„ç›®å½•ï¼Œä½¿ç”¨æ–‡ä»¶åå‰ç¼€æ¨¡æ‹Ÿ
        // /config/system.json
        // /daily/2025-01-01.json
        // /stats/summary.json
        // /logs/system.log
    }
    
    bool writeFile(const String& path, const String& content) {
        File file = SPIFFS.open(path, "w");
        if (!file) return false;
        
        size_t written = file.print(content);
        file.close();
        return written > 0;
    }
    
    String readFile(const String& path) {
        File file = SPIFFS.open(path, "r");
        if (!file) return "";
        
        String content = file.readString();
        file.close();
        return content;
    }
    
    bool fileExists(const String& path) {
        return SPIFFS.exists(path);
    }
    
    void listFiles() {
        File root = SPIFFS.open("/");
        File file = root.openNextFile();
        
        while(file) {
            Serial.printf("æ–‡ä»¶: %s, å¤§å°: %d bytes\n", 
                         file.name(), file.size());
            file = root.openNextFile();
        }
    }
};
```

### æ•°æ®æ¨¡å‹å®šä¹‰

```cpp
// include/v3/data_models.h
struct GameSession {
    String start_time;      // "HH:MM:SS"
    uint32_t duration;      // ç§’
    String difficulty;      // "easy", "normal", "hard"
    uint32_t jump_count;    // è·³è·ƒæ¬¡æ•°
    float calories;         // å¡è·¯é‡Œ
    float max_height;       // æœ€å¤§é«˜åº¦
    float avg_frequency;    // å¹³å‡é¢‘ç‡
};

struct DailyData {
    String date;            // "YYYY-MM-DD"
    std::vector<GameSession> sessions;
    struct {
        uint32_t total_jumps;
        float total_calories;
        uint32_t total_duration;
        uint8_t session_count;
    } daily_total;
};

struct SystemConfig {
    uint8_t volume;         // éŸ³é‡ 0-100
    uint8_t brightness;     // äº®åº¦ 0-100
    uint32_t sleep_timeout; // ç¡çœ è¶…æ—¶(ç§’)
    String difficulty;      // é»˜è®¤éš¾åº¦
    bool auto_sleep;        // è‡ªåŠ¨ç¡çœ 
};
```

## ğŸ“Š æ•°æ®ç®¡ç†ç³»ç»Ÿ

```cpp
// src/v3/data_manager.cpp
class DataManager {
private:
    FileSystemManager* fs;
    SystemConfig config;
    DailyData current_day_data;
    
public:
    bool init(FileSystemManager* filesystem) {
        fs = filesystem;
        loadConfig();
        loadTodayData();
        return true;
    }
    
    bool saveGameSession(const GameSession& session) {
        // æ·»åŠ åˆ°å½“å‰æ—¥æœŸæ•°æ®
        current_day_data.sessions.push_back(session);
        
        // æ›´æ–°æ¯æ—¥ç»Ÿè®¡
        updateDailyTotals();
        
        // ä¿å­˜åˆ°æ–‡ä»¶
        return saveDailyData(current_day_data);
    }
    
    std::vector<DailyData> getHistoryData(uint8_t days = 7) {
        std::vector<DailyData> history;
        
        for (int i = 0; i < days; i++) {
            String date = getDateString(-i); // è·å–iå¤©å‰çš„æ—¥æœŸ
            String filename = "/daily/" + date + ".json";
            
            if (fs->fileExists(filename)) {
                DailyData data = loadDailyData(filename);
                history.push_back(data);
            }
        }
        
        return history;
    }
    
private:
    String serializeDailyData(const DailyData& data) {
        // ä½¿ç”¨ArduinoJsonåº“åºåˆ—åŒ–
        DynamicJsonDocument doc(4096);
        
        doc["date"] = data.date;
        
        JsonArray sessions = doc.createNestedArray("sessions");
        for (const auto& session : data.sessions) {
            JsonObject s = sessions.createNestedObject();
            s["start_time"] = session.start_time;
            s["duration"] = session.duration;
            s["difficulty"] = session.difficulty;
            s["jump_count"] = session.jump_count;
            s["calories"] = session.calories;
            s["max_height"] = session.max_height;
            s["avg_frequency"] = session.avg_frequency;
        }
        
        JsonObject totals = doc.createNestedObject("daily_total");
        totals["total_jumps"] = data.daily_total.total_jumps;
        totals["total_calories"] = data.daily_total.total_calories;
        totals["total_duration"] = data.daily_total.total_duration;
        totals["session_count"] = data.daily_total.session_count;
        
        String output;
        serializeJson(doc, output);
        return output;
    }
};
```

## ğŸ® æ–°åŠŸèƒ½å®ç°

### éš¾åº¦é€‰æ‹©ç³»ç»Ÿ

```cpp
// src/ui/difficulty_view.cpp
class DifficultyView {
private:
    uint8_t selected_difficulty = 1; // 0=å®¹æ˜“, 1=æ™®é€š, 2=å›°éš¾
    const char* difficulty_names[3] = {"å®¹æ˜“", "æ™®é€š", "å›°éš¾"};
    const float difficulty_multipliers[3] = {0.6f, 0.8f, 1.0f};
    
public:
    void render() {
        u8g2.clearBuffer();
        
        // æ ‡é¢˜
        u8g2.setFont(u8g2_font_wqy12_t_chinese1);
        u8g2.drawUTF8(32, 15, "é€‰æ‹©éš¾åº¦");
        
        // éš¾åº¦é€‰é¡¹
        for (int i = 0; i < 3; i++) {
            bool is_selected = (i == selected_difficulty);
            
            // é€‰ä¸­æ¡†
            if (is_selected) {
                u8g2.drawRFrame(10, 25 + i*15, 108, 12, 2);
            }
            
            // éš¾åº¦åç§°
            u8g2.setFont(u8g2_font_wqy12_t_chinese1);
            u8g2.drawUTF8(15, 35 + i*15, difficulty_names[i]);
            
            // éš¾åº¦æè¿°
            String desc = String((int)(difficulty_multipliers[i] * 100)) + "%å¼ºåº¦";
            u8g2.setFont(u8g2_font_6x10);
            u8g2.drawStr(80, 35 + i*15, desc.c_str());
        }
        
        u8g2.sendBuffer();
    }
    
    void handleButton(button_event_t event) {
        if (event == BUTTON_EVENT_SHORT_PRESS) {
            selected_difficulty = (selected_difficulty + 1) % 3;
        } else if (event == BUTTON_EVENT_LONG_PRESS) {
            // ç¡®è®¤é€‰æ‹©ï¼Œè¿”å›æ¸¸æˆ
            game_set_difficulty(selected_difficulty);
            current_state = GAME_STATE_IDLE;
        }
    }
    
    float getDifficultyMultiplier() {
        return difficulty_multipliers[selected_difficulty];
    }
};
```

### å†å²æ•°æ®æŸ¥çœ‹

```cpp
// src/ui/history_view.cpp
class HistoryView {
private:
    std::vector<DailyData> history_data;
    uint8_t current_page = 0;
    uint8_t total_pages = 0;
    
public:
    void init() {
        history_data = data_manager.getHistoryData(7);
        total_pages = (history_data.size() + 2) / 3; // æ¯é¡µæ˜¾ç¤º3å¤©
    }
    
    void render() {
        u8g2.clearBuffer();
        
        // æ ‡é¢˜
        u8g2.setFont(u8g2_font_wqy12_t_chinese1);
        u8g2.drawUTF8(25, 15, "7å¤©è¿åŠ¨è®°å½•");
        
        // é¡µç æŒ‡ç¤º
        String page_info = String(current_page + 1) + "/" + String(total_pages);
        u8g2.setFont(u8g2_font_6x10);
        u8g2.drawStr(100, 15, page_info.c_str());
        
        // æ˜¾ç¤ºå½“å‰é¡µçš„æ•°æ®
        int start_idx = current_page * 3;
        int end_idx = min(start_idx + 3, (int)history_data.size());
        
        for (int i = start_idx; i < end_idx; i++) {
            renderDayData(history_data[i], (i - start_idx) * 16 + 25);
        }
        
        u8g2.sendBuffer();
    }
    
private:
    void renderDayData(const DailyData& data, int y) {
        // æ—¥æœŸ
        u8g2.setFont(u8g2_font_6x10);
        u8g2.drawStr(5, y, data.date.substring(5).c_str()); // æ˜¾ç¤ºMM-DD
        
        // è·³è·ƒæ¬¡æ•°
        String jumps = String(data.daily_total.total_jumps) + "æ¬¡";
        u8g2.drawStr(35, y, jumps.c_str());
        
        // å¡è·¯é‡Œ
        String calories = String((int)data.daily_total.total_calories) + "cal";
        u8g2.drawStr(70, y, calories.c_str());
        
        // æ—¶é•¿
        String duration = String(data.daily_total.total_duration / 60) + "min";
        u8g2.drawStr(100, y, duration.c_str());
    }
};
```

## ğŸ”„ è¿ç§»å’Œå…¼å®¹æ€§

### å¹³æ»‘å‡çº§ç­–ç•¥

```cpp
// src/v3/migration.cpp
class MigrationManager {
public:
    bool checkAndMigrate() {
        String version = getSystemVersion();
        
        if (version.isEmpty() || version == "2.0") {
            return migrateFromV2();
        }
        
        return true; // å·²ç»æ˜¯V3.0
    }
    
private:
    bool migrateFromV2() {
        Serial.println("æ£€æµ‹åˆ°V2.0æ•°æ®ï¼Œå¼€å§‹è¿ç§»...");
        
        // 1. å¤‡ä»½V2.0é…ç½®
        backupV2Config();
        
        // 2. åˆ›å»ºV3.0æ–‡ä»¶ç³»ç»Ÿç»“æ„
        createV3FileSystem();
        
        // 3. è¿ç§»ç”¨æˆ·è®¾ç½®
        migrateUserSettings();
        
        // 4. è®¾ç½®ç‰ˆæœ¬æ ‡è®°
        setSystemVersion("3.0");
        
        Serial.println("æ•°æ®è¿ç§»å®Œæˆ");
        return true;
    }
    
    void createV3FileSystem() {
        // åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶
        SystemConfig default_config = {
            .volume = 80,
            .brightness = 70,
            .sleep_timeout = 300,
            .difficulty = "normal",
            .auto_sleep = true
        };
        
        data_manager.saveConfig(default_config);
    }
};
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ç®¡ç†ä¼˜åŒ–

```cpp
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
class ObjectPool {
private:
    std::vector<GameSession*> session_pool;
    std::vector<bool> session_used;
    
public:
    GameSession* getSession() {
        for (size_t i = 0; i < session_pool.size(); i++) {
            if (!session_used[i]) {
                session_used[i] = true;
                return session_pool[i];
            }
        }
        
        // æ± å·²æ»¡ï¼Œåˆ›å»ºæ–°å¯¹è±¡
        GameSession* session = new GameSession();
        session_pool.push_back(session);
        session_used.push_back(true);
        return session;
    }
    
    void returnSession(GameSession* session) {
        for (size_t i = 0; i < session_pool.size(); i++) {
            if (session_pool[i] == session) {
                session_used[i] = false;
                break;
            }
        }
    }
};
```

### å“åº”æ€§èƒ½ä¼˜åŒ–

```cpp
// å¼‚æ­¥æ•°æ®ä¿å­˜
class AsyncDataSaver {
private:
    QueueHandle_t save_queue;
    TaskHandle_t save_task_handle;
    
public:
    void init() {
        save_queue = xQueueCreate(10, sizeof(SaveRequest));
        xTaskCreate(saveTask, "data_save", 4096, this, 2, &save_task_handle);
    }
    
    void saveAsync(const String& filename, const String& data) {
        SaveRequest request = {filename, data};
        xQueueSend(save_queue, &request, 0);
    }
    
private:
    static void saveTask(void* parameter) {
        AsyncDataSaver* saver = (AsyncDataSaver*)parameter;
        SaveRequest request;
        
        while (true) {
            if (xQueueReceive(saver->save_queue, &request, portMAX_DELAY)) {
                // æ‰§è¡Œå®é™…çš„æ–‡ä»¶ä¿å­˜
                File file = SPIFFS.open(request.filename, "w");
                if (file) {
                    file.print(request.data);
                    file.close();
                }
            }
        }
    }
};
```

---

è¿™ä¸ªæŠ€æœ¯å®æ–½æ–¹æ¡ˆæä¾›äº†V3.0é‡æ„çš„è¯¦ç»†æŠ€æœ¯è·¯çº¿å›¾ï¼ŒåŒ…æ‹¬ç¡¬ä»¶é€‚é…ã€æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®ç®¡ç†ã€æ–°åŠŸèƒ½å®ç°ç­‰å„ä¸ªæ–¹é¢çš„å…·ä½“å®ç°æ–¹æ¡ˆã€‚
