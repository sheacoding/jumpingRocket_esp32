# 🔧 蹦跳小火箭 V3.0 技术实施方案

## 📋 技术架构对比

### V2.0 vs V3.0 架构对比

| 层级 | V2.0 当前架构 | V3.0 目标架构 | 主要变化 |
|------|---------------|---------------|----------|
| **硬件层** | ESP32 DevKit | ESP32-C3 Mini | 更小体积，内置天线 |
| **存储层** | 内存变量 | SPIFFS文件系统 | 持久化存储，大容量 |
| **数据层** | 临时数据 | JSON格式文件 | 结构化数据，易扩展 |
| **功能层** | 基础游戏 | 增强功能集 | 难度选择，历史记录 |
| **电源层** | 简单供电 | 智能电源管理 | 深度睡眠，续航优化 |
| **扩展层** | 无 | 预留接口 | Wi-Fi/蓝牙准备 |

## 🔌 硬件适配方案

### ESP32-C3 Mini 引脚规划

```cpp
// include/v3/board_config_v3.h
#ifndef BOARD_CONFIG_V3_H
#define BOARD_CONFIG_V3_H

// ESP32-C3 Mini 专用配置
#ifdef BOARD_ESP32_C3_MINI
    #define BOARD_NAME "ESP32-C3 Mini V3.0"
    
    // 核心功能引脚
    #define I2C_SDA_PIN         8     // I2C数据线
    #define I2C_SCL_PIN         0    // I2C时钟线
    #define BUTTON_PIN          3     // 用户按钮
    #define BUZZER_PIN          4     // 蜂鸣器PWM
    
    // 扩展功能引脚
    ~~#define STATUS_LED_PIN      3     // 状态指示LED~~
    ~~#define BATTERY_ADC_PIN     0     // 电池电压检测~~
    ~~#define WAKEUP_PIN          9     // 深度睡眠唤醒引脚~~
    
    // 硬件特性配置
    #define I2C_FREQUENCY       100000  // 100kHz，稳定优先
    #define BUTTON_ACTIVE_LEVEL HIGH    // 高电平触发
    #define BUTTON_PULL_MODE    INPUT_PULLDOWN
    
    // 电源管理配置
    #define DEEP_SLEEP_ENABLED  1
    #define BATTERY_MONITOR_ENABLED 1
    #define LOW_BATTERY_THRESHOLD 3.3   // 低电量阈值(V)
    
#endif

#endif // BOARD_CONFIG_V3_H
```

### 电源管理系统

```cpp
// src/v3/power_manager.cpp
class PowerManager {
private:
    float battery_voltage;
    bool low_battery_warning;
    uint32_t sleep_timeout;
    
public:
    void init() {
        // 配置ADC用于电池电压检测
        analogReadResolution(12);
        analogSetAttenuation(ADC_11db);
        
        // 配置唤醒源
        esp_sleep_enable_ext0_wakeup(GPIO_NUM_9, 1); // 按钮唤醒
        esp_sleep_enable_timer_wakeup(30 * 60 * 1000000ULL); // 30分钟定时唤醒
    }
    
    float getBatteryVoltage() {
        int raw = analogRead(BATTERY_ADC_PIN);
        return (raw * 3.3 * 2) / 4095.0; // 分压电路计算
    }
    
    bool isLowBattery() {
        return getBatteryVoltage() < LOW_BATTERY_THRESHOLD;
    }
    
    void enterDeepSleep() {
        Serial.println("进入深度睡眠模式");
        esp_deep_sleep_start();
    }
    
    void handleWakeup() {
        esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
        
        switch(wakeup_reason) {
            case ESP_SLEEP_WAKEUP_EXT0:
                Serial.println("按钮唤醒");
                break;
            case ESP_SLEEP_WAKEUP_TIMER:
                Serial.println("定时器唤醒");
                break;
            default:
                Serial.println("正常启动");
                break;
        }
    }
};
```

## 💾 文件系统设计

### 数据存储架构

```cpp
// src/v3/file_system.cpp
class FileSystemManager {
private:
    bool fs_initialized;
    
public:
    bool init() {
        if (!SPIFFS.begin(true)) {
            Serial.println("SPIFFS初始化失败");
            return false;
        }
        
        // 创建目录结构
        createDirectoryStructure();
        fs_initialized = true;
        return true;
    }
    
    void createDirectoryStructure() {
        // SPIFFS不支持真正的目录，使用文件名前缀模拟
        // /config/system.json
        // /daily/2025-01-01.json
        // /stats/summary.json
        // /logs/system.log
    }
    
    bool writeFile(const String& path, const String& content) {
        File file = SPIFFS.open(path, "w");
        if (!file) return false;
        
        size_t written = file.print(content);
        file.close();
        return written > 0;
    }
    
    String readFile(const String& path) {
        File file = SPIFFS.open(path, "r");
        if (!file) return "";
        
        String content = file.readString();
        file.close();
        return content;
    }
    
    bool fileExists(const String& path) {
        return SPIFFS.exists(path);
    }
    
    void listFiles() {
        File root = SPIFFS.open("/");
        File file = root.openNextFile();
        
        while(file) {
            Serial.printf("文件: %s, 大小: %d bytes\n", 
                         file.name(), file.size());
            file = root.openNextFile();
        }
    }
};
```

### 数据模型定义

```cpp
// include/v3/data_models.h
struct GameSession {
    String start_time;      // "HH:MM:SS"
    uint32_t duration;      // 秒
    String difficulty;      // "easy", "normal", "hard"
    uint32_t jump_count;    // 跳跃次数
    float calories;         // 卡路里
    float max_height;       // 最大高度
    float avg_frequency;    // 平均频率
};

struct DailyData {
    String date;            // "YYYY-MM-DD"
    std::vector<GameSession> sessions;
    struct {
        uint32_t total_jumps;
        float total_calories;
        uint32_t total_duration;
        uint8_t session_count;
    } daily_total;
};

struct SystemConfig {
    uint8_t volume;         // 音量 0-100
    uint8_t brightness;     // 亮度 0-100
    uint32_t sleep_timeout; // 睡眠超时(秒)
    String difficulty;      // 默认难度
    bool auto_sleep;        // 自动睡眠
};
```

## 📊 数据管理系统

```cpp
// src/v3/data_manager.cpp
class DataManager {
private:
    FileSystemManager* fs;
    SystemConfig config;
    DailyData current_day_data;
    
public:
    bool init(FileSystemManager* filesystem) {
        fs = filesystem;
        loadConfig();
        loadTodayData();
        return true;
    }
    
    bool saveGameSession(const GameSession& session) {
        // 添加到当前日期数据
        current_day_data.sessions.push_back(session);
        
        // 更新每日统计
        updateDailyTotals();
        
        // 保存到文件
        return saveDailyData(current_day_data);
    }
    
    std::vector<DailyData> getHistoryData(uint8_t days = 7) {
        std::vector<DailyData> history;
        
        for (int i = 0; i < days; i++) {
            String date = getDateString(-i); // 获取i天前的日期
            String filename = "/daily/" + date + ".json";
            
            if (fs->fileExists(filename)) {
                DailyData data = loadDailyData(filename);
                history.push_back(data);
            }
        }
        
        return history;
    }
    
private:
    String serializeDailyData(const DailyData& data) {
        // 使用ArduinoJson库序列化
        DynamicJsonDocument doc(4096);
        
        doc["date"] = data.date;
        
        JsonArray sessions = doc.createNestedArray("sessions");
        for (const auto& session : data.sessions) {
            JsonObject s = sessions.createNestedObject();
            s["start_time"] = session.start_time;
            s["duration"] = session.duration;
            s["difficulty"] = session.difficulty;
            s["jump_count"] = session.jump_count;
            s["calories"] = session.calories;
            s["max_height"] = session.max_height;
            s["avg_frequency"] = session.avg_frequency;
        }
        
        JsonObject totals = doc.createNestedObject("daily_total");
        totals["total_jumps"] = data.daily_total.total_jumps;
        totals["total_calories"] = data.daily_total.total_calories;
        totals["total_duration"] = data.daily_total.total_duration;
        totals["session_count"] = data.daily_total.session_count;
        
        String output;
        serializeJson(doc, output);
        return output;
    }
};
```

## 🎮 新功能实现

### 难度选择系统

```cpp
// src/ui/difficulty_view.cpp
class DifficultyView {
private:
    uint8_t selected_difficulty = 1; // 0=容易, 1=普通, 2=困难
    const char* difficulty_names[3] = {"容易", "普通", "困难"};
    const float difficulty_multipliers[3] = {0.6f, 0.8f, 1.0f};
    
public:
    void render() {
        u8g2.clearBuffer();
        
        // 标题
        u8g2.setFont(u8g2_font_wqy12_t_chinese1);
        u8g2.drawUTF8(32, 15, "选择难度");
        
        // 难度选项
        for (int i = 0; i < 3; i++) {
            bool is_selected = (i == selected_difficulty);
            
            // 选中框
            if (is_selected) {
                u8g2.drawRFrame(10, 25 + i*15, 108, 12, 2);
            }
            
            // 难度名称
            u8g2.setFont(u8g2_font_wqy12_t_chinese1);
            u8g2.drawUTF8(15, 35 + i*15, difficulty_names[i]);
            
            // 难度描述
            String desc = String((int)(difficulty_multipliers[i] * 100)) + "%强度";
            u8g2.setFont(u8g2_font_6x10);
            u8g2.drawStr(80, 35 + i*15, desc.c_str());
        }
        
        u8g2.sendBuffer();
    }
    
    void handleButton(button_event_t event) {
        if (event == BUTTON_EVENT_SHORT_PRESS) {
            selected_difficulty = (selected_difficulty + 1) % 3;
        } else if (event == BUTTON_EVENT_LONG_PRESS) {
            // 确认选择，返回游戏
            game_set_difficulty(selected_difficulty);
            current_state = GAME_STATE_IDLE;
        }
    }
    
    float getDifficultyMultiplier() {
        return difficulty_multipliers[selected_difficulty];
    }
};
```

### 历史数据查看

```cpp
// src/ui/history_view.cpp
class HistoryView {
private:
    std::vector<DailyData> history_data;
    uint8_t current_page = 0;
    uint8_t total_pages = 0;
    
public:
    void init() {
        history_data = data_manager.getHistoryData(7);
        total_pages = (history_data.size() + 2) / 3; // 每页显示3天
    }
    
    void render() {
        u8g2.clearBuffer();
        
        // 标题
        u8g2.setFont(u8g2_font_wqy12_t_chinese1);
        u8g2.drawUTF8(25, 15, "7天运动记录");
        
        // 页码指示
        String page_info = String(current_page + 1) + "/" + String(total_pages);
        u8g2.setFont(u8g2_font_6x10);
        u8g2.drawStr(100, 15, page_info.c_str());
        
        // 显示当前页的数据
        int start_idx = current_page * 3;
        int end_idx = min(start_idx + 3, (int)history_data.size());
        
        for (int i = start_idx; i < end_idx; i++) {
            renderDayData(history_data[i], (i - start_idx) * 16 + 25);
        }
        
        u8g2.sendBuffer();
    }
    
private:
    void renderDayData(const DailyData& data, int y) {
        // 日期
        u8g2.setFont(u8g2_font_6x10);
        u8g2.drawStr(5, y, data.date.substring(5).c_str()); // 显示MM-DD
        
        // 跳跃次数
        String jumps = String(data.daily_total.total_jumps) + "次";
        u8g2.drawStr(35, y, jumps.c_str());
        
        // 卡路里
        String calories = String((int)data.daily_total.total_calories) + "cal";
        u8g2.drawStr(70, y, calories.c_str());
        
        // 时长
        String duration = String(data.daily_total.total_duration / 60) + "min";
        u8g2.drawStr(100, y, duration.c_str());
    }
};
```

## 🔄 迁移和兼容性

### 平滑升级策略

```cpp
// src/v3/migration.cpp
class MigrationManager {
public:
    bool checkAndMigrate() {
        String version = getSystemVersion();
        
        if (version.isEmpty() || version == "2.0") {
            return migrateFromV2();
        }
        
        return true; // 已经是V3.0
    }
    
private:
    bool migrateFromV2() {
        Serial.println("检测到V2.0数据，开始迁移...");
        
        // 1. 备份V2.0配置
        backupV2Config();
        
        // 2. 创建V3.0文件系统结构
        createV3FileSystem();
        
        // 3. 迁移用户设置
        migrateUserSettings();
        
        // 4. 设置版本标记
        setSystemVersion("3.0");
        
        Serial.println("数据迁移完成");
        return true;
    }
    
    void createV3FileSystem() {
        // 创建默认配置文件
        SystemConfig default_config = {
            .volume = 80,
            .brightness = 70,
            .sleep_timeout = 300,
            .difficulty = "normal",
            .auto_sleep = true
        };
        
        data_manager.saveConfig(default_config);
    }
};
```

## 📈 性能优化

### 内存管理优化

```cpp
// 使用对象池减少内存分配
class ObjectPool {
private:
    std::vector<GameSession*> session_pool;
    std::vector<bool> session_used;
    
public:
    GameSession* getSession() {
        for (size_t i = 0; i < session_pool.size(); i++) {
            if (!session_used[i]) {
                session_used[i] = true;
                return session_pool[i];
            }
        }
        
        // 池已满，创建新对象
        GameSession* session = new GameSession();
        session_pool.push_back(session);
        session_used.push_back(true);
        return session;
    }
    
    void returnSession(GameSession* session) {
        for (size_t i = 0; i < session_pool.size(); i++) {
            if (session_pool[i] == session) {
                session_used[i] = false;
                break;
            }
        }
    }
};
```

### 响应性能优化

```cpp
// 异步数据保存
class AsyncDataSaver {
private:
    QueueHandle_t save_queue;
    TaskHandle_t save_task_handle;
    
public:
    void init() {
        save_queue = xQueueCreate(10, sizeof(SaveRequest));
        xTaskCreate(saveTask, "data_save", 4096, this, 2, &save_task_handle);
    }
    
    void saveAsync(const String& filename, const String& data) {
        SaveRequest request = {filename, data};
        xQueueSend(save_queue, &request, 0);
    }
    
private:
    static void saveTask(void* parameter) {
        AsyncDataSaver* saver = (AsyncDataSaver*)parameter;
        SaveRequest request;
        
        while (true) {
            if (xQueueReceive(saver->save_queue, &request, portMAX_DELAY)) {
                // 执行实际的文件保存
                File file = SPIFFS.open(request.filename, "w");
                if (file) {
                    file.print(request.data);
                    file.close();
                }
            }
        }
    }
};
```

---

这个技术实施方案提供了V3.0重构的详细技术路线图，包括硬件适配、文件系统、数据管理、新功能实现等各个方面的具体实现方案。
